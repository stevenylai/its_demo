package pubsub.edl2.frontendComposite;

import java_cup.runtime.*;
import pubsub.edl2.middlend.*;
import java.util.Stack;
import java_cup.runtime.DefaultSymbolFactory;

action code {:
	GenericTreeNode root;
:}
parser code  {:
  Lexer lexer;
	static private GenericTreeNode root;

  public Parser(Lexer l) {
    this();
		symbolFactory = new DefaultSymbolFactory();
    lexer=l;
  }

	static public void setRoot (GenericTreeNode g) { root = g; }
	static public GenericTreeNode getRoot () { return root; }
  public void syntax_error(java_cup.runtime.Symbol current) {
    report_error("Syntax error (" + current.sym + ")", current);
  }
  public void report_error(String message, java_cup.runtime.Symbol info) {
    lexer.errorMsg(message, info);
  }
:};

scan with {: return lexer.next_token(); :};

terminal BOOLEAN; // primitive_type
terminal BYTE, SHORT, INT, LONG; // integral_type
terminal IDENTIFIER; // name
terminal EVENT; // event_declaration
terminal DOT; // qualified_name
terminal SEMICOLON, MULT, COMMA, LBRACE, RBRACE, EQ, LPAREN, RPAREN;

terminal PLUSPLUS; // postincrement_expression
terminal MINUSMINUS; // postdecrement_expression
terminal PLUS, MINUS, NOT, DIV, MOD;
terminal LSHIFT, RSHIFT, URSHIFT; // shift_expression
terminal LT, GT, LTEQ, GTEQ; // relational_expression
terminal EQEQ, NOTEQ; // equality_expression
terminal AND; // and_expression
terminal XOR; // exclusive_or_expression
terminal OR;  // inclusive_or_expression
terminal ANDAND; // conditional_and_expression
terminal OROR; // conditional_or_expression
terminal MULTEQ, DIVEQ, MODEQ, PLUSEQ, MINUSEQ; // assignment_operator
terminal LSHIFTEQ, RSHIFTEQ; // assignment_operator
terminal ANDEQ, XOREQ, OREQ; // assignment_operator

terminal WHERE; // where_expression
terminal AREA; // area_expression
terminal ON; // on_expression
terminal SUBSCRIBE; // add-on keyword

//terminal java.lang.Number INTEGER_LITERAL;
terminal INTEGER_LITERAL;
//terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal BOOLEAN_LITERAL;

// 19.2) The Syntactic Grammar
non terminal goal;
// 19.3) Lexical Structure
non terminal literal;

non terminal type_declarations_opt, type_declarations, type_declaration;
//non terminal block;

// Events
non terminal event_declaration, event_body, filter_body, filter_body_opt, on_clause_opt, on_clause;
non terminal field_declarations_opt, field_declarations;

// Subscribe statement
non terminal subscribe_statement;

// Expressions
non terminal primary, primary_no_new_array;
non terminal argument_list_opt, argument_list;
non terminal method_invocation;
non terminal postfix_expression;
non terminal postincrement_expression, postdecrement_expression;
non terminal unary_expression, unary_expression_not_plus_minus;
non terminal preincrement_expression, predecrement_expression;
non terminal multiplicative_expression, additive_expression;
non terminal shift_expression, relational_expression, equality_expression;
non terminal and_expression, exclusive_or_expression, inclusive_or_expression;
non terminal conditional_and_expression, conditional_or_expression;
non terminal conditional_expression, assignment_expression;
//non terminal assignment;
//non terminal assignment_operator;
non terminal expression;

// Types / Variables
non terminal type, primitive_type, reference_type, numeric_type;
non terminal integral_type;
non terminal field_declaration, variable_declarators, variable_declarator;
non terminal variable_declarator_id, variable_initializer;
non terminal name, simple_name, qualified_name;

start with goal;

goal ::=	{: root = new goal(); Parser.setRoot(root); :}
	type_declarations_opt:d {: RESULT=root; :}
	;

// Lexical Structure.
literal ::=
		INTEGER_LITERAL:e1 {: RESULT=new Literal(Literal.INTEGER, (String)e1); :}
	|	BOOLEAN_LITERAL:e2 {: RESULT=new Literal(Literal.BOOLEAN, (String)e2); :}
	;

type_declarations_opt   ::= | type_declarations:d {: RESULT=d; :};

type_declarations ::= 
		type_declaration:t {: RESULT=t; :}
	|	type_declarations type_declaration:t {: RESULT=t; :}
	;

// Events
type_declaration ::=
		event_declaration:d {: RESULT=d; :}
	| subscribe_statement:s {: RESULT=s; :}
	;

event_declaration ::= 
	EVENT IDENTIFIER:id event_body:b on_clause_opt:o filter_body_opt:f
	{: event_declaration d=new event_declaration((String)id); d.addChild((GenericTreeNode)b); d.addChild((GenericTreeNode)o); d.addChild((GenericTreeNode)f); root.addChild((GenericTreeNode)d); RESULT=d;	:}
	;

event_body ::=
	LBRACE field_declarations_opt:f RBRACE {: RESULT=f; :}
	;
on_clause ::=
	ON LBRACE field_declarations_opt:f RBRACE {: RESULT=f; :}
	;

filter_body_opt ::=
	|filter_body:f {: RESULT=f; :}
	;

on_clause_opt ::=
	|on_clause:o {: RESULT=o; :}
	;

filter_body ::=
	WHERE LBRACE conditional_expression:e RBRACE {: RESULT=e; :}
	;

// Subscription
subscribe_statement ::=
	SUBSCRIBE IDENTIFIER:id SEMICOLON {: subscribe_statement ss = new subscribe_statement(); ss.addChild(new Identifier((String)id)); root.addChild((GenericTreeNode)ss); RESULT=ss; :}
	;

// Fields
field_declarations_opt ::=
	| field_declarations:f {: field_declarations fd = new field_declarations(); fd.addChild((GenericTreeNode)f); RESULT=fd; :}
	;

field_declarations ::=
	field_declaration:f1 {: RESULT=f1; :}
	| field_declarations:f2 field_declaration:f3 {: ((GenericTreeNode)f2).addChild((GenericTreeNode)f3); RESULT=f2; :}
	;

field_declaration ::= 
		type:t variable_declarators:v SEMICOLON {: field_declaration f = new field_declaration();f.addChild((GenericTreeNode)t);variable_declarators vd=new variable_declarators();f.addChild(vd);vd.addChild((GenericTreeNode)v); RESULT=f; :}
	;

// Variables
variable_declarators ::=
		variable_declarator:vd {: RESULT=vd; :}
	|	variable_declarators:vds COMMA variable_declarator:d {: ((GenericTreeNode)vds).addChild((GenericTreeNode)d); RESULT=vds; :}
	;
variable_declarator ::=
		variable_declarator_id:i {: variable_declarator vd1=new variable_declarator();vd1.addChild((GenericTreeNode)i);RESULT=vd1; :}
	|	variable_declarator_id:i EQ variable_initializer:in {: variable_declarator vd=new variable_declarator();vd.addChild((GenericTreeNode)i);vd.addChild((GenericTreeNode)in);RESULT=vd; :}
	;
variable_declarator_id ::=
		IDENTIFIER:i {: RESULT=new Identifier((String)i); :}
	;
variable_initializer ::=
		expression:e {: RESULT=e; :}
	;
name	::=	simple_name:sn {: name n =new name(); n.addChild((GenericTreeNode)sn); RESULT=n; :}
	|	qualified_name:qn {: RESULT=qn; :}
	;
qualified_name ::=
		name:n DOT IDENTIFIER:i {: ((GenericTreeNode)n).addChild((GenericTreeNode)new Identifier((String)i)); RESULT=n; :}
	;
simple_name ::=	IDENTIFIER:i {: RESULT=new Identifier((String)i); :}
	;

// Filters


// Types
type	::=	primitive_type:p {: RESULT=p; :}
	|	reference_type:p2 {: RESULT=p2; :}
	;
primitive_type ::=
		numeric_type:t {: RESULT=t; :}
	|	BOOLEAN {: RESULT=new primitive_type("boolean"); :}
	;
reference_type ::=
		simple_name:n {: RESULT=n; :}
	;
numeric_type::=	integral_type:t {: RESULT=t; :}
	;
integral_type ::= 
		BYTE {: RESULT=new primitive_type("byte"); :}
	|	SHORT {: RESULT=new primitive_type("short"); :}
	|	INT {: RESULT=new primitive_type("int"); :}
	|	LONG {: RESULT=new primitive_type("long"); :}
	;

// Expressions
expression ::=	assignment_expression:e {: RESULT=e; :}
	;
assignment_expression ::=
		conditional_expression:e1 {: RESULT=e1; :}
	;
/*assignment_operator ::=
		EQ {: RESULT=new assignment_operator("="); :}
	;*/
primary ::=	primary_no_new_array:e {: RESULT=e; :}
	;
primary_no_new_array ::=
		literal:e1 {: RESULT=e1; :}
	|	method_invocation:e6 {: RESULT=e6; :}
	;

argument_list_opt ::=
	|	argument_list:a {: argument_list arglist = new argument_list();arglist.addChild((GenericTreeNode)a);RESULT=arglist; :}
	;
argument_list ::=
		expression:e1 {: argument a = new argument();a.addChild((GenericTreeNode)e1);RESULT=a; :}
	|	argument_list:e2 COMMA expression:e3 {: argument a = new argument();a.addChild((GenericTreeNode)e3);((GenericTreeNode)e2).addChild(a);RESULT=e2; :}
	;
method_invocation ::=
		IDENTIFIER:e1 LPAREN argument_list_opt:e2 RPAREN {: method_invocation mi=new method_invocation();mi.addChild((GenericTreeNode)e1);mi.addChild((GenericTreeNode)e2);RESULT=mi; :}
	;
postfix_expression ::=
		primary:e1 {: RESULT=e1; :}
	//|	name:e2 {: name na = new name();na.addChild((GenericTreeNode)e2);RESULT=na; :}
	|	name:e2 {: RESULT=e2; :}
	|	postincrement_expression:e3 {: RESULT=e3; :}
	|	postdecrement_expression:e4 {: RESULT=e4; :}
	;
postincrement_expression ::=
		postfix_expression:e1 PLUSPLUS {: postincrement_expression e=new postincrement_expression("++");e.addChild((GenericTreeNode)e1);RESULT=e; :}
	;
postdecrement_expression ::=
		postfix_expression:e1 MINUSMINUS {: postdecrement_expression e=new postdecrement_expression("--");e.addChild((GenericTreeNode)e1);RESULT=e; :}
	;
unary_expression ::=
		preincrement_expression:e1 {: RESULT=e1; :}
	|	predecrement_expression:e2 {: RESULT=e2; :}
	|	PLUS unary_expression:e3 {: unary_expression e=new unary_expression("+");e.addChild((GenericTreeNode)e3);RESULT=e; :}
	|	MINUS unary_expression:e4 {: unary_expression e=new unary_expression("-");e.addChild((GenericTreeNode)e4);RESULT=e; :}
	|	unary_expression_not_plus_minus:e5 {: RESULT=e5; :}
	;
preincrement_expression ::=
		PLUSPLUS unary_expression:e1 {: preincrement_expression e=new preincrement_expression("++");e.addChild((GenericTreeNode)e1);RESULT=e; :}
	;
predecrement_expression ::=
		MINUSMINUS unary_expression:e1 {: predecrement_expression e=new predecrement_expression("--");e.addChild((GenericTreeNode)e1);RESULT=e; :}
	;
unary_expression_not_plus_minus ::=
		postfix_expression:e1 {: RESULT=e1; :}
	|	NOT unary_expression:e2 {: unary_expression_not_plus_minus e=new unary_expression_not_plus_minus("!");e.addChild((GenericTreeNode)e2);RESULT=e; :}
	;
multiplicative_expression ::=
		unary_expression:e1 {: RESULT=e1; :}
	|	multiplicative_expression:e2 MULT unary_expression:e3 {: multiplicative_expression e=new multiplicative_expression("*");e.addChild((GenericTreeNode)e2);e.addChild((GenericTreeNode)e3);RESULT=e; :}
	|	multiplicative_expression:e4 DIV unary_expression:e5 {: multiplicative_expression e=new multiplicative_expression("/");e.addChild((GenericTreeNode)e4);e.addChild((GenericTreeNode)e5);RESULT=e; :}
	|	multiplicative_expression:e6 MOD unary_expression:e7 {: multiplicative_expression e=new multiplicative_expression("%");e.addChild((GenericTreeNode)e6);e.addChild((GenericTreeNode)e7);RESULT=e; :}
	;
additive_expression ::=
		multiplicative_expression:e1 {: RESULT=e1; :}
	|	additive_expression:e2 PLUS multiplicative_expression:e3 {: additive_expression e=new additive_expression("+");e.addChild((GenericTreeNode)e2);e.addChild((GenericTreeNode)e3);RESULT=e; :}
	|	additive_expression:e4 MINUS multiplicative_expression:e5 {: additive_expression e=new additive_expression("-");e.addChild((GenericTreeNode)e4);e.addChild((GenericTreeNode)e5);RESULT=e; :}
	;
shift_expression ::=
		additive_expression:e1 {: RESULT=e1; :}
	|	shift_expression:e2 LSHIFT additive_expression:e3 {: shift_expression e=new shift_expression("<<");e.addChild((GenericTreeNode)e2);e.addChild((GenericTreeNode)e3);RESULT=e; :}
	|	shift_expression:e4 RSHIFT additive_expression:e5 {: shift_expression e=new shift_expression(">>");e.addChild((GenericTreeNode)e4);e.addChild((GenericTreeNode)e5);RESULT=e; :}
	;
relational_expression ::=
		shift_expression:e1 {: RESULT=e1; :}
	|	relational_expression:e2 LT shift_expression:e3 {: relational_expression e=new relational_expression("<");e.addChild((GenericTreeNode)e2);e.addChild((GenericTreeNode)e3);RESULT=e; :}
	|	relational_expression:e4 GT shift_expression:e5 {: relational_expression e=new relational_expression(">");e.addChild((GenericTreeNode)e4);e.addChild((GenericTreeNode)e5);RESULT=e; :}
	|	relational_expression:e6 LTEQ shift_expression:e7 {: relational_expression e=new relational_expression("<=");e.addChild((GenericTreeNode)e6);e.addChild((GenericTreeNode)e7);RESULT=e; :}
	|	relational_expression:e8 GTEQ shift_expression:e9 {: relational_expression e=new relational_expression(">=");e.addChild((GenericTreeNode)e8);e.addChild((GenericTreeNode)e9);RESULT=e; :}
	;
equality_expression ::=
		relational_expression:e1 {: RESULT=e1; :}
	|	equality_expression:e2 EQEQ relational_expression:e3 {: equality_expression e=new equality_expression("==");e.addChild((GenericTreeNode)e2);e.addChild((GenericTreeNode)e3);RESULT=e; :}
	|	equality_expression:e4 NOTEQ relational_expression:e5 {: equality_expression e=new equality_expression("!=");e.addChild((GenericTreeNode)e4);e.addChild((GenericTreeNode)e5);RESULT=e; :}
	;
and_expression ::=
		equality_expression:e1 {: RESULT=e1; :}
	|	and_expression:e2 AND equality_expression:e3 {: and_expression e=new and_expression("&");e.addChild((GenericTreeNode)e2);e.addChild((GenericTreeNode)e3);RESULT=e; :}
	;
exclusive_or_expression ::=
		and_expression:e1 {: RESULT=e1; :}
	|	exclusive_or_expression:e2 XOR and_expression:e3 {: exclusive_or_expression e=new exclusive_or_expression("^");e.addChild((GenericTreeNode)e2);e.addChild((GenericTreeNode)e3);RESULT=e; :}
	;
inclusive_or_expression ::=
		exclusive_or_expression:e1 {: RESULT=e1; :}
	|	inclusive_or_expression:e2 OR exclusive_or_expression:e3 {: inclusive_or_expression e=new inclusive_or_expression("|");e.addChild((GenericTreeNode)e2);e.addChild((GenericTreeNode)e3);RESULT=e; :}
	;
conditional_and_expression ::=
		inclusive_or_expression:e1 {: RESULT=e1; :}
	|	conditional_and_expression:e2 ANDAND inclusive_or_expression:e3 {: conditional_and_expression e=new conditional_and_expression("&&");e.addChild((GenericTreeNode)e2);e.addChild((GenericTreeNode)e3);RESULT=e; :}
	;
conditional_or_expression ::=
		conditional_and_expression:e1 {: RESULT=e1; :}
	|	conditional_or_expression:e2 OROR conditional_and_expression:e3 {: conditional_or_expression e=new conditional_or_expression("||");e.addChild((GenericTreeNode)e2);e.addChild((GenericTreeNode)e3);RESULT=e; :}
	;
conditional_expression ::=
		conditional_or_expression:e {: RESULT=e; :}
	;
